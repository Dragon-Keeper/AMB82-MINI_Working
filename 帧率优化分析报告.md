# Camera_2_Lcd_JPEGDEC å¸§ç‡ä¼˜åŒ–åˆ†ææŠ¥å‘Š

## å½“å‰æ€§èƒ½çŠ¶å†µ
- **å®é™…FPS**: 3.5å¸§/ç§’
- **ç›®æ ‡FPS**: 15å¸§/ç§’
- **æ€§èƒ½å·®è·**: éœ€è¦æå‡çº¦4.3å€æ€§èƒ½

## æ€§èƒ½ç“¶é¢ˆåˆ†æ

### 1. ä¸»è¦æ€§èƒ½ç“¶é¢ˆè¯†åˆ«

#### 1.1 JPEGè§£ç æ€§èƒ½ç“¶é¢ˆ ğŸ”´ **é«˜ä¼˜å…ˆçº§**
- **é—®é¢˜**: `jpeg.decode()` æ˜¯ä¸»è¦æ€§èƒ½æ¶ˆè€—ç‚¹
- **å½“å‰é…ç½®**: ä½¿ç”¨`JPEG_SCALE_QUARTER`ç¼©æ”¾
- **å½±å“**: è§£ç è¿‡ç¨‹å ç”¨çº¦60-70%çš„å¤„ç†æ—¶é—´

#### 1.2 å›¾åƒæ•°æ®ä¼ è¾“ç“¶é¢ˆ ğŸ”´ **é«˜ä¼˜å…ˆçº§**
- **é—®é¢˜**: `drawBitmapOptimized()` å‡½æ•°å¤„ç†å¤§æ•°æ®é‡ä¼ è¾“
- **å½“å‰å¤„ç†**: WVGAåˆ†è¾¨ç‡(800Ã—480)å³ä½¿ç¼©æ”¾åä»ç„¶æ•°æ®é‡å·¨å¤§
- **å½±å“**: æ•°æ®ä¼ è¾“å ç”¨çº¦20-30%çš„å¤„ç†æ—¶é—´

#### 1.3 å¸§ç‡æ§åˆ¶é€»è¾‘ç¼ºé™· ğŸŸ¡ **ä¸­ä¼˜å…ˆçº§**
- **é—®é¢˜**: ç®€å•çš„å¸§é—´éš”æ§åˆ¶æ— æ³•é€‚åº”åŠ¨æ€å¤„ç†æ—¶é—´
- **å½“å‰å®ç°**: å›ºå®š66msé—´éš”æ£€æŸ¥
- **å½±å“**: æ— æ³•å……åˆ†åˆ©ç”¨å¯ç”¨å¤„ç†æ—¶é—´

#### 1.4 å†…å­˜ç®¡ç†é—®é¢˜ ğŸŸ¡ **ä¸­ä¼˜å…ˆçº§**
- **é—®é¢˜**: é¢‘ç¹çš„JPEGè§£ç å™¨å¼€å…³æ“ä½œ
- **å½“å‰å®ç°**: æ¯æ¬¡æ–°å›¾åƒéƒ½é‡æ–°åˆå§‹åŒ–è§£ç å™¨
- **å½±å“**: å¢åŠ ä¸å¿…è¦çš„åˆå§‹åŒ–å¼€é”€

### 2. ç¡¬ä»¶èµ„æºåˆ†æ

#### 2.1 å¤„ç†å™¨æ€§èƒ½é™åˆ¶
- **ä¸»æ§**: AMB82-MINI (Realtek RTL8735B)
- **ä¸»é¢‘**: çº¦100MHz
- **æ€§èƒ½**: ä¸­ç­‰æ€§èƒ½MCUï¼Œéœ€è¦ä¼˜åŒ–ç®—æ³•æ•ˆç‡

#### 2.2 æ˜¾ç¤ºæ¥å£æ€§èƒ½
- **æ¥å£**: 8ä½å¹¶è¡Œæ¥å£
- **ç†è®ºå¸¦å®½**: çº¦8-16MB/s
- **å®é™…ç“¶é¢ˆ**: è½¯ä»¶æ§åˆ¶æ—¶åºé™åˆ¶

#### 2.3 æ‘„åƒå¤´æ•°æ®æµ
- **åˆ†è¾¨ç‡**: WVGA (800Ã—480)
- **æ ¼å¼**: JPEGå‹ç¼©
- **æ•°æ®é‡**: æ¯å¸§çº¦50-200KBï¼ˆå–å†³äºå‹ç¼©ç‡ï¼‰

## ç³»ç»Ÿæ€§ä¼˜åŒ–æ–¹æ¡ˆ

### é˜¶æ®µä¸€ï¼šæ ¸å¿ƒç®—æ³•ä¼˜åŒ– ğŸ”¥ **ç«‹å³å®æ–½**

#### 1.1 åˆ†è¾¨ç‡ä¼˜åŒ–
```cpp
// ä¼˜åŒ–æ–¹æ¡ˆï¼šè¿›ä¸€æ­¥é™ä½å¤„ç†åˆ†è¾¨ç‡
// å½“å‰ï¼šWVGA (800Ã—480) -> JPEG_SCALE_QUARTER (200Ã—120)
// å»ºè®®ï¼šä½¿ç”¨æ›´ä½åˆ†è¾¨ç‡æˆ–æ›´å¤§ç¼©æ”¾æ¯”ä¾‹

// æ–¹æ¡ˆAï¼šä½¿ç”¨VGAåˆ†è¾¨ç‡
VideoSetting config(VIDEO_VGA, CAM_FPS, VIDEO_JPEG, 1);
// æ–¹æ¡ˆBï¼šä½¿ç”¨QVGAåˆ†è¾¨ç‡  
VideoSetting config(VIDEO_QVGA, CAM_FPS, VIDEO_JPEG, 1);
// æ–¹æ¡ˆCï¼šä½¿ç”¨JPEG_SCALE_EIGHTH
jpeg.decode(0, 0, JPEG_SCALE_EIGHTH);
```

#### 1.2 JPEGè§£ç ä¼˜åŒ–
```cpp
// ä¼˜åŒ–è§£ç å‚æ•°
jpeg.setMaxOutputSize(5);        // ä»10é™ä½åˆ°5ï¼Œå‡å°‘å†…å­˜å ç”¨
jpeg.setOptions(JPEG_LUMA_ONLY); // ä»…è§£ç äº®åº¦åˆ†é‡ï¼Œæå‡é€Ÿåº¦
jpeg.setOptions(JPEG_LE_PIXELS); // å°ç«¯åƒç´ æ ¼å¼ï¼Œæå‡æ•ˆç‡
```

#### 1.3 æ™ºèƒ½å¸§ç‡æ§åˆ¶
```cpp
// è‡ªé€‚åº”å¸§ç‡æ§åˆ¶
#define MIN_FRAME_TIME 50    // æœ€å°å¸§é—´éš”20ms (50FPSä¸Šé™)
#define TARGET_FRAME_TIME 66 // ç›®æ ‡å¸§é—´éš”15ms (15FPS)

unsigned long adaptiveFrameControl() {
    static unsigned long lastFrameEnd = 0;
    static float fpsAdjustment = 1.0;
    
    unsigned long currentTime = millis();
    unsigned long frameTime = currentTime - lastFrameEnd;
    
    // åŠ¨æ€è°ƒæ•´å¸§ç‡ç›®æ ‡
    if (frameTime < TARGET_FRAME_TIME) {
        // å¤„ç†è¿‡å¿«ï¼Œç¨å¾®å»¶è¿Ÿ
        return TARGET_FRAME_TIME - frameTime;
    } else {
        // å¤„ç†è¿‡æ…¢ï¼Œç«‹å³å¼€å§‹ä¸‹ä¸€å¸§
        return 0;
    }
}
```

### é˜¶æ®µäºŒï¼šå†…å­˜å’Œç¼“å­˜ä¼˜åŒ– ğŸš€ **é‡è¦æ”¹è¿›**

#### 2.1 åŒç¼“å†²æœºåˆ¶
```cpp
// å®ç°åŒç¼“å†²æœºåˆ¶
#define DOUBLE_BUFFER_ENABLED true

struct FrameBuffer {
    uint16_t* buffer;
    uint32_t addr;
    uint32_t len;
    bool ready;
} frameBuffers[2];

int currentBuffer = 0;
bool bufferReady = false;

// å¼‚æ­¥è§£ç å‡½æ•°
void decodeToBuffer(uint32_t addr, uint32_t len, int bufferIndex) {
    if (jpeg.openFLASH((uint8_t*)addr, len, JPEGDraw)) {
        // è§£ç åˆ°æŒ‡å®šç¼“å†²åŒº
        jpeg.decode(0, 0, JPEG_SCALE_QUARTER);
        frameBuffers[bufferIndex].ready = true;
    }
}
```

#### 2.2 æ™ºèƒ½ç¼“å­˜ç­–ç•¥
```cpp
// æ™ºèƒ½å›¾åƒç¼“å­˜
#define SMART_CACHE_ENABLED true

struct SmartImageCache {
    uint32_t addr;
    uint32_t len;
    uint16_t* decodedBuffer;
    unsigned long timestamp;
    int hitCount;
} smartCache;

// ç¼“å­˜å†³ç­–ç®—æ³•
bool shouldCacheImage(uint32_t addr, uint32_t len) {
    // åŸºäºå›¾åƒå¤§å°å’Œå¤„ç†æ—¶é—´å†³å®šæ˜¯å¦ç¼“å­˜
    if (len > 100000) return false;  // å¤§å›¾åƒä¸ç¼“å­˜
    if (smartCache.hitCount > 3) return true; // é«˜é¢‘å›¾åƒç¼“å­˜
    return false;
}
```

### é˜¶æ®µä¸‰ï¼šæ˜¾ç¤ºæ¸²æŸ“ä¼˜åŒ– âš¡ **æ€§èƒ½æå‡**

#### 3.1 åŒºåŸŸæ›´æ–°ä¼˜åŒ–
```cpp
// å®ç°åŒºåŸŸæ›´æ–°ï¼Œåªåˆ·æ–°å˜åŒ–éƒ¨åˆ†
#define REGIONAL_UPDATE_ENABLED true

struct UpdateRegion {
    int x, y, w, h;
    bool changed;
} updateRegion;

// æ£€æµ‹å›¾åƒå˜åŒ–åŒºåŸŸ
void detectChangedRegion(uint16_t* newImage, uint16_t* oldImage) {
    // ç®€åŒ–çš„å˜åŒ–æ£€æµ‹ç®—æ³•
    int minX = 999, maxX = -1, minY = 999, maxY = -1;
    
    for (int y = 0; y < imageHeight; y += 4) { // æ¯4è¡Œæ£€æŸ¥ä¸€æ¬¡
        for (int x = 0; x < imageWidth; x += 4) { // æ¯4åˆ—æ£€æŸ¥ä¸€æ¬¡
            if (newImage[y * imageWidth + x] != oldImage[y * imageWidth + x]) {
                minX = min(minX, x);
                maxX = max(maxX, x);
                minY = min(minY, y);
                maxY = max(maxY, y);
            }
        }
    }
    
    if (maxX >= minX) {
        updateRegion.x = minX;
        updateRegion.y = minY;
        updateRegion.w = maxX - minX + 1;
        updateRegion.h = maxY - minY + 1;
        updateRegion.changed = true;
    }
}
```

#### 3.2 å¹¶è¡Œå¤„ç†ä¼˜åŒ–
```cpp
// å®ç°è§£ç å’Œæ˜¾ç¤ºçš„å¹¶è¡Œå¤„ç†
#define PARALLEL_PROCESSING true

// çŠ¶æ€æœºå®ç°
enum ProcessingState {
    STATE_IDLE,
    STATE_DECODING,
    STATE_DISPLAYING,
    STATE_COMPLETE
};

ProcessingState currentState = STATE_IDLE;

void parallelProcessingLoop() {
    switch (currentState) {
        case STATE_IDLE:
            // æ£€æŸ¥æ–°å›¾åƒ
            if (newImageAvailable()) {
                startDecoding();
                currentState = STATE_DECODING;
            }
            break;
            
        case STATE_DECODING:
            // æ£€æŸ¥è§£ç æ˜¯å¦å®Œæˆ
            if (decodingComplete()) {
                startDisplaying();
                currentState = STATE_DISPLAYING;
            }
            break;
            
        case STATE_DISPLAYING:
            // æ£€æŸ¥æ˜¾ç¤ºæ˜¯å¦å®Œæˆ
            if (displayingComplete()) {
                currentState = STATE_COMPLETE;
            }
            break;
    }
}
```

### é˜¶æ®µå››ï¼šç¡¬ä»¶çº§ä¼˜åŒ– ğŸ”§ **æ·±åº¦ä¼˜åŒ–**

#### 4.1 DMAä¼ è¾“ä¼˜åŒ–
```cpp
// å®ç°DMAåŠ é€Ÿä¼ è¾“ï¼ˆå¦‚æœç¡¬ä»¶æ”¯æŒï¼‰
#define DMA_TRANSFER_ENABLED false // éœ€è¦ç¡¬ä»¶æ”¯æŒ

void dmaTransfer(uint16_t* data, int length) {
    // DMAé…ç½®å’Œå¯åŠ¨
    // è¿™éœ€è¦å…·ä½“çš„ç¡¬ä»¶DMAæ”¯æŒ
}
```

#### 4.2 ä¸­æ–­é©±åŠ¨ä¼˜åŒ–
```cpp
// å®ç°ä¸­æ–­é©±åŠ¨çš„æ˜¾ç¤ºæ›´æ–°
#define INTERRUPT_DRIVEN false // éœ€è¦ç¡¬ä»¶æ”¯æŒ

void displayInterruptHandler() {
    // å¤„ç†æ˜¾ç¤ºå®Œæˆä¸­æ–­
    displayBusy = false;
    // è§¦å‘ä¸‹ä¸€å¸§å¤„ç†
}
```

## å®æ–½ä¼˜å…ˆçº§å’Œæ—¶é—´ä¼°ç®—

### ç¬¬ä¸€é˜¶æ®µï¼ˆç«‹å³å®æ–½ï¼‰- é¢„æœŸæå‡è‡³8-10 FPS
1. **åˆ†è¾¨ç‡ä¼˜åŒ–** - 2å°æ—¶
2. **JPEGè§£ç å‚æ•°ä¼˜åŒ–** - 1å°æ—¶  
3. **å¸§ç‡æ§åˆ¶ä¼˜åŒ–** - 1å°æ—¶
4. **å†…å­˜ç®¡ç†ä¼˜åŒ–** - 2å°æ—¶

### ç¬¬äºŒé˜¶æ®µï¼ˆé‡è¦æ”¹è¿›ï¼‰- é¢„æœŸæå‡è‡³12-14 FPS
1. **åŒç¼“å†²æœºåˆ¶** - 4å°æ—¶
2. **æ™ºèƒ½ç¼“å­˜ç­–ç•¥** - 3å°æ—¶
3. **åŒºåŸŸæ›´æ–°ä¼˜åŒ–** - 3å°æ—¶

### ç¬¬ä¸‰é˜¶æ®µï¼ˆæ·±åº¦ä¼˜åŒ–ï¼‰- é¢„æœŸè¾¾åˆ°15+ FPS
1. **å¹¶è¡Œå¤„ç†** - 6å°æ—¶
2. **ç¡¬ä»¶çº§ä¼˜åŒ–** - 8å°æ—¶ï¼ˆéœ€è¦ç¡¬ä»¶æ”¯æŒéªŒè¯ï¼‰

## é¢„æœŸæ€§èƒ½æå‡

| ä¼˜åŒ–é˜¶æ®µ | å½“å‰FPS | ç›®æ ‡FPS | é¢„æœŸæå‡ |
|----------|---------|---------|----------|
| é˜¶æ®µä¸€   | 3.5     | 8-10    | +150%    |
| é˜¶æ®µäºŒ   | 8-10    | 12-14   | +40%     |
| é˜¶æ®µä¸‰   | 12-14   | 15+     | +15%     |

## éªŒè¯å’Œæµ‹è¯•æ–¹æ¡ˆ

### æ€§èƒ½åŸºå‡†æµ‹è¯•
```cpp
// æ·»åŠ è¯¦ç»†çš„æ€§èƒ½ç›‘æ§
#define PERFORMANCE_MONITORING true

struct PerformanceMetrics {
    unsigned long decodeTime;
    unsigned long displayTime;
    unsigned long totalFrameTime;
    int frameCount;
    float averageFPS;
} metrics;

void logPerformance() {
    Serial.print("Decode: "); Serial.print(metrics.decodeTime); Serial.println("ms");
    Serial.print("Display: "); Serial.print(metrics.displayTime); Serial.println("ms");
    Serial.print("Total: "); Serial.print(metrics.totalFrameTime); Serial.println("ms");
    Serial.print("FPS: "); Serial.println(metrics.averageFPS);
}
```

### å†…å­˜ä½¿ç”¨ç›‘æ§
```cpp
// æ·»åŠ å†…å­˜ä½¿ç”¨ç›‘æ§
#define MEMORY_MONITORING true

void logMemoryUsage() {
    Serial.print("Free Heap: "); Serial.println(ESP.getFreeHeap());
    Serial.print("Largest Free Block: "); Serial.println(ESP.getMaxAllocHeap());
}
```

## ç»“è®º

é€šè¿‡ç³»ç»Ÿæ€§çš„å››é˜¶æ®µä¼˜åŒ–ï¼Œé¢„æœŸèƒ½å¤Ÿå°†FPSä»å½“å‰çš„3.5å¸§/ç§’ç¨³å®šæå‡è‡³15å¸§/ç§’ä»¥ä¸Šã€‚å…³é”®åœ¨äºï¼š

1. **ç«‹å³å®æ–½**åˆ†è¾¨ç‡é™ä½å’Œç®—æ³•ä¼˜åŒ–ï¼Œè·å¾—æœ€å¤§æ€§èƒ½æå‡
2. **é‡ç‚¹æ”¹è¿›**å†…å­˜ç®¡ç†å’Œç¼“å­˜ç­–ç•¥ï¼Œå‡å°‘é‡å¤å¤„ç†
3. **æ·±åº¦ä¼˜åŒ–**å¹¶è¡Œå¤„ç†å’Œç¡¬ä»¶åŠ é€Ÿï¼Œè¾¾åˆ°æœ€ç»ˆç›®æ ‡

å»ºè®®æŒ‰é˜¶æ®µé€æ­¥å®æ–½ï¼Œæ¯é˜¶æ®µå®Œæˆåè¿›è¡Œæ€§èƒ½æµ‹è¯•ï¼Œç¡®ä¿ä¼˜åŒ–æ•ˆæœã€‚